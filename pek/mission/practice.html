<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>
  <body></body>
  <script type="text/javascript" src="../../js_static/js/jquery-3.6.0.min.js"></script>
  <script>
    //230324 - 자바스크립트 기초 강의
    function class230324() {
      let name = 'Mike'; //변할 수 있는 값은 let, 프로젝트에서 많이 쓰임
      const d = d; //절대로 바뀌지 않는 상수, 대문자로 하는게 좋음

      //Boolean
      const a = true;
      const b = false;
      //null - 존재하지 않는다, undefined - 선언되지 않음

      //잘못된 예시
      //const mathScore = prompt("수학 몇점?");
      //const engScore = prompt("영어 몇점?");
      //const result = (mathScore + engScore) / 2;

      //거듭제곱 : 2**3
      //우선순위 : * /   >    + -

      let num = 10;
      //num = num + 5
      num += 5;

      let num00 = 10;
      let result = ++num00; //값을 증가시키려면 ++는 앞에다가

      //10!=5 10은 5와 다르다 true
      // ==은 숫자형, 문자형 다 되지만 버그를 만들 수 있음 , ===는 문자형인지 숫자형인지까지 확인함

      // OR
      if (name === 'Tom' || age > 19) {
        //console.log('통과')
      } else {
        //console.log('나가')
      }

      //NOT
      if (!age > 19) {
        //console.log('돌아가') - 19살보다 많지 않으면 돌아가
      }

      //우선순위
      if ((gender === 'M' && name === 'Mike') || age) {
        //&&가 우선순위가 높기 때문에 ||가 부합되지 않아도 true가 됨
        //console.log('통과')
      } else {
        //console.log('돌아가')
      }
      // 위의 식을 원하는대로 하려면 if(gender === 'M' && (name === 'Mike' || age)) 이렇게 한번 더 묶어야함

      //반복문 loop - 동일한 작업을 여러번 반복
      //대표적으로 for문 : for(let i = 0; i<10;i++){}
      // let i = 0 이 초기값
      //i<10 조건
      //i++ 코드실행 후 작업됨
      //조건이 false 되면 return 됨

      //while 반복문
      let i = 0;
      while (i < 10) {
        i++;
        //10보다 작다는 조건이 맞으면 i가 증가된다
      }

      //do..while
      let i01 = 0;

      do {
        i01++; //코드를 먼저 실행하고 조건을 체크함, 거의 안씀
      } while (i < 10);

      //break, continue
      //break - 실행을 멈춤
      //continue - 실행을 멈추지 않고 점프함

      while (true) {
        let answer = confirm('계속할까요?');
        if (!answer) {
          break;
        }
      }

      for (let i = 0; i < 10; i++) {
        if (i % 2) {
          continue; //결국 짝수만 남음
        }
      }

      //switch문
      //case가 다양할경우 보다 간결하게 사용 (=if)
      let fruit = prompt('무슨과일을 사고싶나요');
      switch (fruit) {
        case '사과':
          console.log('100원입니다');
          break;
        case '바나나':
          console.log('200원입니다');
          break;
        case '멜론':
        case '키위':
          console.log('300원입니다');
          break;
        default: //else if 같은 역할
          console.log('그런 과일은 없습니다');
      }
      //break를 쓰지 않으면 그 이후 케이스까지 다 동작함

      //function  함수
      function showError() {
        alert('에러가 발생했습니다. 다시 시도해주세요.');
      } //이렇게 쓰면 유지보수가 쉽다
      //매개변수가 있는 함수
      function sayHello(name) {
        const msg = `hello, ${name}`;
        console.log(msg);
      }
      function sayHello01(name) {
        let msg = `hello`; //함수안에서만 사용하는 변수 - 지역변수
        if (name) {
          msg += ', ' + name;
        }
        console.log(msg);
      }

      //전역변수와 지역변수
      let meet = 'welcome'; //전역

      function meetHello(name) {
        let msg = 'hello'; //지역
        console.log(msg + ' ' + name);
      }
      //지역변수를 주로 쓰는게 좋음

      //or
      function hello(name) {
        let newName = name || 'friend';
        let msg = `hello, ${name}`;
        console.log(msg);
      }
      //reture으로 값 반환
      function add(num1, num2) {
        return num1 + num2;
      }
      const result01 = add(2, 3); //2+3을 한 후 5를 반환함

      //한 함수에 한작업만 하는게 좋음
      //읽기쉬운 네이밍

      //함수선언문 vs 함수표현식
      function bluh() {
        console.log('이것은 함수선언문');
        //어디서든 호출 가능 (호이스팅)
      }
      let bluhbluh = function () {
        console.log('이것은 함수표현식');
        //함수 생성 이후에만 사용가능
      };
      //화살표함수
      let addd = (num1, num2) => {
        console.log('이것은 화살표함수');
      };
      //인수가 두개이고 리턴문이 있음 - 간단하게 줄일수 있음
      const adddd = (num1, num2) => num1 + num2;

      //객체 object
      //객체
      const superman = {
        name: 'clark',
        age: '33'
      };
      //객체접근
      superman.name;
      superman['age'];
      //추가
      superman.gender = 'male';
      superman['hairColor'] = 'black';
      //삭제
      delete superman.hairColor;

      //프로퍼티 존재여부확인
      superman.birthDay;
      //undefined
      'birthDay' in superman;
      //false
      'age' in superman;
      //true

      //for문 사용시
      for (let key in superman) {
        console.log(key);
        console.log(superman[key]);
      }

      // function makeObject(name, age){
      //   return{
      //     name : name,
      //     age : age,
      //     hobby : 'football'
      //   }
      // }
      //위의 식을 축약
      function makeObject(name, age) {
        return {
          name,
          age,
          hobby: 'football'
        };
      }
      const mike = makeObject('mike', 30);
      console.log(mike);

      console.log('age' in mike); //마이크에 나이가 있는지 구분
      console.log('birthday' in mike); //마이크에 생일이 있는지 없는지 구분

      //활용
      function isAdult(user) {
        if (!('age' in user) || user.age < 20) {
          //유저안에 나이가 없거나 20살 미만이면
          return false; //false가 된다.
        }
        return false;
      }

      const Mike = {
        name: 'mike',
        age: 30
      };
      const jane = {
        name: 'jane'
      };

      console.log(isAdult(jane));
      //for..in문 활용
      for (x in mike) {
        console.log(mike[x]); //Mike['age']
      }

      //객제 안의 메소드
      //화사ㄹ표 안에서 this를 가지고 있지 않기 때문에 this를 사용하면 안됨

      let boy = {
        name: 'mike',
        showName: function () {
          console.log(this.name);
        },
        sayThis: () => {
          console.log(this);
        } //화살표는 쓰지 않는게 좋음
      };
      let man = boy;
      boy = null;

      man.showName();

      //array 배열
      //순서가 있는 리스트
      //배열의 특징 : 숫자 객체 함수 등등 포함가능, length() 배열의 길이 반환, puch() 배열 제일 뒤에 추가시킴,pop()은 요소를 제거
      //shift, unshift : 추가 삭제 여러개도 가능
      //for문 , for..of 문도 활용가능

      let days = ['mon', 'tue', 'wed'];

      days[1] = '화요일';
      days.push('thu'); //목요일 추가
      days.unshift('sun'); //제일 앞에 일요일 추가

      for (let index = 0; index < days.length; index++) {
        console.log(days[index]);
      }
      for (let day of days) {
        console.log(day);
      }
    }

    //230327 중급강의
    function class0327() {
      //생성자함수
      function User(name, age) {
        //첫글자 대문자
        this.name = name;
        this.age = age;
        this.sayName = function () {
          console.log(this.name);
        };
      }
      let user1 = new User('mike', 30); //new 연산자로 함수 호출
      let user2 = new User('Jane', 22);
      let user3 = new User('tom', 17);
      let user5 = new User('han', 40);

      user5.sayName(); //han
      //생성자함수는 붕어빵 틀과 같아서 비슷한 데이터를 찍어냄
      //new 함수명(); 을 실행하는 순간 함수에 쓰인대로 출력됨

      //예시
      function Item(title, price) {
        this.title = title; // this = {}
        this.price = price;
        this.showPrice = function () {
          console.log(`가격은 ${price}원 입니다.`);
        };
        const item1 = new Item('doll', 3000);
        const item2 = new Item('bag', 4000);
        const item3 = new Item('neckless', 9000);

        console.log(item1, item2, item3);

        item3.showPrice();
      }

      //computed property
      let a = 'age'; //변수
      const userNamed = {
        //객체
        name: 'Mike',
        [a]: 30 //객체에 변수
      };

      //Object.assign() : 객체복제
      const newUser = Object.assign({}, user);
      newUser.name = 'tom';
      //두개 이상의 객체 합치기도 가능 Object.assign(a,b,c)

      //Object.keys() : 키 배열 반환
      const user = {
        name: 'nike',
        age: 30,
        gender: 'male'
      };
      Object.keys(user); //name,age,gender

      //반대로 값 배열 반환 - .values(nike,30,male)
      //.entries() : 키/값 배열반환 - ([name: 'nike'],[age: 30],[gender: 'male'])
      //.fromEntries() 키/값 배열을 객체로 - name: 'nike', age: 30, gender: 'male'

      //예시
      function makeObj(key, val) {
        return {
          [key]: val
        };
      }
      const obj = makeObj('성별', 'male');

      console.log(obj);

      //객체복제
      const userInfo = {
        name: 'mike',
        age: 30
      };

      const userInfo2 = Object.assign({}, userInfo);
      user2.name = 'tom';

      console.log(userInfo); //마이크 이름이 나옴
      console.log(userInfo2); // 톰의 이름이 나옴

      const result = Object.keys(userInfo); //name, age
      const result02 = Object.value(userInfo); //mike, 30
      const result03 = Object.entries(userInfo); // 둘다 나옴 - 배열로

      let arr = [
        ['mon', '월'],
        ['tue', '화']
      ];
      const result04 = Object.fromEntries(arr); //배열을 객체로 만듬

      //심볼
      //const a = Symbol('id'); new를 붙이지 않음
      //유일성이 보장
      //object 메소드에선 심볼형이 생략되서 출력됨

      //전역심볼 : Symbol.for()
      //하나의 심볼만 보장
      //하나를 생성 후 키를 통해 공유가능
      //예시
      //다른 개발자가 만들어 놓은 객체
      const symUser = {
        name: 'mike',
        age: 30
      };
      // 내가작업
      const showNameSym = Symbol('show name');
      symUser[showNameSym] = function () {
        //객체를 덮어쓸 필요없이 생성가능
        console.log(this.name); //이름만 보여줘
      };
      symUser[showNameSym]();
      //사용자가 접속하면 보는 메시지
      for (let key in symUser) {
        console.log(`his ${key} is ${symUser[key]}.`);
      }

      //Number, math
      //toString()
      let num = 10;
      num.toString(); //10
      num.toString(); //1010

      //math
      //소수점 올림 - ceil
      let num1 = 5.1;
      let num2 = 5.7;

      math.ceil(num1); //6
      math.ceil(num2); //6

      //소수점 내림 - floor
      let num001 = 5.1;
      let num002 = 5.7;

      math.floor(num001); //5
      math.floor(num002); //5

      //소수점 자릿수 - round
      //요구사항 : 소수점 둘째자리까지 표현(셋째자리에서 반올림)
      let userRate = 30.1234;

      math.round(userRate * 100) / 100; //30.12

      //소수점 자릿수 - toFixed
      //요구사항 : 위와 동일
      userRate.toFixed(2); //30.12

      //Nan은 let X = Number('x') //NaN 일 때, x==NaN을 false로 인식한다.
      //NaN == NaN 또한 false로 인식한다.
      //위 식을 충족하기 위해선 isNaN(x)를 해야 true로 인식한다.

      //parseInt() - 문자를 숫자로 반환
      let redColor = 'f3';
      parseInt(redColor); //NaN

      parseInt(redColor, 16); //243 - 16진수로 반환

      //parseFloat()
      let padding = '18.5%';

      parseInt(padding); //18 소수점 제외 반환
      parseFloat(padding); //18.5 소수점까지 반환

      //Math.random()
      //0~1사이 무작위 숫자 생성
      //1 ~ 100사이 임의의 숫자를 뽑고 싶다면?
      Math.floor(Math.random() * 100) + 1;

      //Math.max() / min()
      //괄호 안의 인수들 중 최소값, 최대값을 구할 수 있음
      Math.max(1, 4, -1, 5, 10, 9, 5.54); //10
      Math.min(1, 4, -1, 5, 10, 9, 5.54); //-1

      //Math.abs() :절대값
      Math.abs(-1); //1

      //Math.pow(n,m) :제곱
      Math.pow(2, 10); //1024 2의 10승

      //sqrt() : 제곱근
      Math.sqrt(16); //4

      //str.indexOf(text) 문자를 인수로 받음
      let desc = 'Hi guys Nice to meet you';
      desc.indexOf('to'); //14
      desc.indexOf('man'); //-1

      //str.slice(n,m) 문자 내 범위
      let desc1 = 'abcdefg';

      desc.slice(2); //"cedfg"
      desc.slice(0, 5); //"abcde"
      desc.slice(2, -2); //cde 2~ 끝에서 두번째

      //예제 : 금칙어 콜라
      //includes를 써서 문자가 있으면 true, 없으면 false로 구분할 수 있음
      function hasCola(str) {
        if (str.indexOf('콜라') > -1) {
          console.log('금칙어가 있습니다.');
        } else {
          console.log('통과');
        }
        hasCola('와 사이다가 짱이야'); //-1
        hasCola('먼솔 콜라가 최고');
        hasCola('콜라'); //0
      }

      //array 배열에 관하여
      //splice(n,m) : 특정요소 지움
      let array00 = [1, 2, 3, 4, 5];
      array00.splice(1, 2);

      console.log(array00); //1,4,5
      //splice(n,m,x) : 특정요소 지우고 추가
      let array01 = ['나는', '철수', '입니다'];

      array01.splice(1, 0, '대한민국', '소방관');

      //splice는 삭제된 요소를 반환 할 수도 있음
      let result05 = array00.splice(1, 2);
      //결과 값 2,3

      //slice(n,m) : n부터m까지 반환하는 메서드
      //concat(arr2,arr3...) : 합쳐서 새배열 반환
      //forEach(fn) : 배열반복
      let user6 = ['Mike', 'Tom', 'Jane'];

      user6.forEach((item,index,arr)=>{
        //item:mike tom jane  idex:0,1,2,.. arr
      });

      //indexOf / lastIndexOf
      user6.indexOf('Tom'); //1

      //includes():포함하는지 확인
      //find(fn) / findIndex(fn) 첫번째 true 값만 반환하고 끝

      let arr4 = [1,2,3,4,5];

      const result06 = arr4.find((item)=> {
        return item % 2 === 0;
      });

      console.log(result06); //2

      let userList = [
        {name : 'Mike', age:30},
        {name : 'jane', age:27},
        {name : 'tom', age:10},
      ];
      userList.findIndex((user)=>{
        if(user.age< 19){
          return true;
        }
        return false;
      });
      console.log(result);

      //filter(fn) 조건에 맞는 배열을 출력

      //map
      let newUserList = userList.map((user,index)=>{
        return Object.assign({}, user,{
          id: index +1,
          isAdult: user.age > 19,
        });
      });

      console.log(newUserList); // tom은 미성년자로 확인

      //예제 2
      //join, split
      let arr5 = ["안녕", "나는", "철수야"];
      let result07 = arr5.join(" "); //문자열 사이에 공백주기
      const result08 = str.split(""); //각 문자열에 말따옴표

      //예제 3
      //isArray()
      let user7 = {
        name : "Miek",
        age : 30,
      };

      let userList00 = ["mike", "tom", "jane"];

      console.log(typeof user7);
      console.log(typeof userList00);
      console.log(Array.isArray(user7)); //false
      console.log(Array.isArray(userList00)); //true

      //sort()/reduce()
      //sort 배열 재정렬 배열자체가 재정렬됨

      let arr6 = ["a", "c", "d", "e", "b", "f"];
      let arr7 = [27,8,5,13];

      arr6.sort();

      arr7.sort((a,b)=>{
        console.log(a,b);
        return a-b;
      }); //5,8,13,27

      console.log(arr6); // "a", "b", "c", "d", "e", "f"
      //정렬할 때 문자로 인식
      //하지만 계산식이 어려워서 보통은 Lodash같은 라이브러리를 사용한다
      //lodash를 쓰면 _.sortBy(arr)로 사용가능

      //reduce 배열의 모든 수 합치기
      const result09 = arr4.reduce((prev, cur)=>{
        return prev + cur;
      },0);//초기값 0
      console.log(result09); //15
      //reduceRight 배열 우측부터 연산

      //구조분해할당
      //배열 구조 분해 / 객체구조분해

      //매개변수와 전개구문
      //인수전달
      function showName(name){
        console.log(arguments.length); //갯수
        console.log(arguments[0]);
        console.log(arguments[1]);
      }
      showName('mike,tom'); //2 'mike' 'tom'
      //arguments
      //함수로 넘어온 모든 인수에 접근
      //함수내에서 이용가능한 지역변수
      //lenght/index
      //array 형태의 객체
      //배열의 내장 메서드 없음

      //나머지 매개변수
      //정해지지 않은 변수를 전달

      //예제
      /*나머지 매개변수/ 전달받은 모든 수를 더해야함*/

      function add(...number){ //변화가 될 수 있는 값 ... 나머지 매개변수는 항상 마지막에
        let result10 = 0;
        numbers.forEach((num)=>(result10 +=num));
        console.log(result10);
      }
      add(1,2,3);

      //전개구문
      let arr01 = [1,2,3];
      let arr02 = [4,5,6];

      arr01 = [...arr02, arr01];

      console.log(arr01); // 4,5,6,1,2,3

      //closure 클로저
      //어휘적 환경(lexical environment)
      //함수와 렉시컬 환경의 조합
      //함수가 생성될 당시의 외부 변수를 기억
      //생성 이후에도 계속 접근 가능

      //setTimeout / setInterval
      //setTimeout - 일정시간이 지난뒤 실행
      //setInterval - 반복실행
      let num3 = 0;
      function showTime(){
        console.log(`안녕하세요. 접속하신지 ${num3++}초가 지났습니다.`);
      }
      setInterval(showTime, 1000);
      //1초마다 출력

      //5초 뒤 끝남
      function showTime(){
        console.log(`안녕하세요. 접속하신지 ${num3++}초가 지났습니다.`);
        if(num3 > 5) {
          clearInterval(tId);
        }
      }
      const tId = setInterval(showTime, 1000);

      //call
      //모든 함수에서 사용가능 this를 특정값으로 지정가능
      //함수명.call() - 함수의 this가 할당됨

      //apply
      //매개변수를 배열로 받을 수 있다 배열형태로 받는다

      //bind
      //함수의 this 값을 영구히 바꿀 수 있다.

      //상속, 프로토타입
      //__proto__: 프로토타입이라고 함
      //
  </script>
</html>
